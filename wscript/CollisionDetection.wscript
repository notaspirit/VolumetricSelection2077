// @author spirit
// @version 0.0.1
// @description
// Main Processing Script for the CtrlADel project


// The string that will be generated by the CET side of the mod
// Quat will always be 0 0 0 0 as far I am aware
const InputString = '{"selectionBox": {"min": {"x":-1319.258, "y":1209.688, "z":111.717, "w":0}, "max": {"x":-1365.696, "y":1234.248, "z":143.492, "w":0}, "quat": {"i":0, "j":0, "k":0, "r":0}}, "sectors": ["base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-6_4_0_3.streamingsector", "base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-43_37_3_0.streamingsector","base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-42_37_3_0.streamingsector","base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-22_18_2_1.streamingsector","base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-22_18_1_1.streamingsector","base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-21_18_2_1.streamingsector","base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-21_18_1_1.streamingsector","base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\interior_-11_9_0_2.streamingsector","base\\\\worlds\\\\03_night_city\\\\_compiled\\\\default\\\\exterior_-22_16_1_0.streamingsector"]}';

// limit selection to specific type of node, leave blank for all, supports partial string matching, seperation by spaces
// Note: This is case sensitive
const SelectVariable = "";

// Skip Processing Steps
// Can be skipped for performance, but will introduce edgecases
const skipInclusionCheck = false;
const skipFaceCheck = false;
// Not recommended to skip
const skipEdgeCheck = false;

// Changing code below this point is not recommended

// Imports
import * as Logger from 'Logger.wscript';
import * as TypeHelper from 'TypeHelper.wscript';

// Parsing the input string into a json object
const InputJson = JSON.parse(InputString);

// Function to turn search string into an array
function stringToArray(searchString) {
    return searchString.split(" ");
}

const SelectVariableArray = stringToArray(SelectVariable);

// Function to calculate the 3D vector connecting two points
function vectorBetweenPoints(pointA, pointB) {
    return [
        pointB.x - pointA.x,
        pointB.y - pointA.y,
        pointB.z - pointA.z
    ];
}

// Function to convert a relative coordinate to an absolute coordinate
function relativeToAbsoluteCoord(relativeCoord, referenceCoord) {
    return [relativeCoord.x + referenceCoord.x, relativeCoord.y + referenceCoord.y, relativeCoord.z + referenceCoord.z];
}

// Cube class to handle the cube's vertices,quaternion and edge/face calculations
class Cube {
    constructor(minPoint, maxPoint, quat) {
        this.vertices = this.minMaxToVertices(minPoint, maxPoint);
        this.edges = this.calculateEdges(this.vertices);
        this.faces = this.calculateFaces(this.vertices);
        this.quat = quat;
        this.minPoint = minPoint;
        this.maxPoint = maxPoint;
    }

    minMaxToVertices(minPoint, maxPoint) {
        return [
            {x: minPoint.x, y: minPoint.y, z: minPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1},
            {x: maxPoint.x, y: minPoint.y, z: minPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1},
            {x: maxPoint.x, y: maxPoint.y, z: minPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1},
            {x: minPoint.x, y: maxPoint.y, z: minPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1},
            {x: minPoint.x, y: minPoint.y, z: maxPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1},
            {x: maxPoint.x, y: minPoint.y, z: maxPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1},
            {x: maxPoint.x, y: maxPoint.y, z: maxPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1},
            {x: minPoint.x, y: maxPoint.y, z: maxPoint.z, w: minPoint.w !== undefined ? minPoint.w : 1}
        ];
    }

    calculateEdges(vertices) {
        return [
            {points: [vertices[0], vertices[1]], vector: vectorBetweenPoints(vertices[0], vertices[1])},
            {points: [vertices[1], vertices[2]], vector: vectorBetweenPoints(vertices[1], vertices[2])},
            {points: [vertices[2], vertices[3]], vector: vectorBetweenPoints(vertices[2], vertices[3])},
            {points: [vertices[3], vertices[0]], vector: vectorBetweenPoints(vertices[3], vertices[0])},
            {points: [vertices[4], vertices[5]], vector: vectorBetweenPoints(vertices[4], vertices[5])},
            {points: [vertices[5], vertices[6]], vector: vectorBetweenPoints(vertices[5], vertices[6])},
            {points: [vertices[6], vertices[7]], vector: vectorBetweenPoints(vertices[6], vertices[7])},
            {points: [vertices[7], vertices[4]], vector: vectorBetweenPoints(vertices[7], vertices[4])},
            {points: [vertices[0], vertices[4]], vector: vectorBetweenPoints(vertices[0], vertices[4])},
            {points: [vertices[1], vertices[5]], vector: vectorBetweenPoints(vertices[1], vertices[5])},
            {points: [vertices[2], vertices[6]], vector: vectorBetweenPoints(vertices[2], vertices[6])},
            {points: [vertices[3], vertices[7]], vector: vectorBetweenPoints(vertices[3], vertices[7])}
        ];
    }

    calculateFaces(vertices) {
        return [
            // Front face
            [vertices[0], vertices[1], vertices[2]],
            [vertices[0], vertices[2], vertices[3]],
            // Back face
            [vertices[4], vertices[5], vertices[6]],
            [vertices[4], vertices[6], vertices[7]],
            // Top face
            [vertices[3], vertices[2], vertices[6]],
            [vertices[3], vertices[6], vertices[7]],
            // Bottom face
            [vertices[0], vertices[1], vertices[5]],
            [vertices[0], vertices[5], vertices[4]],
            // Left face
            [vertices[0], vertices[3], vertices[7]],
            [vertices[0], vertices[7], vertices[4]],
            // Right face
            [vertices[1], vertices[2], vertices[6]],
            [vertices[1], vertices[6], vertices[5]]
        ];
    }
}

// Sphere Class to handle the sphere's center and radius
class Sphere {
    constructor(center, radius) {
        this.center = center;
        this.radius = radius;
    }
}

// Creating the selector cube
const SelectionBox = new Cube(InputJson.selectionBox.min, InputJson.selectionBox.max, InputJson.selectionBox.quat);

// How the output json should look like
// let OutputJson = {"sector": {"name": "", "nodes": {"AXLindex": 0, "type": "", "actors": []}}};
let OutputJson = {};

/*
AXL Index is the index that is used in the AXL file -> nodeData
Index is the index that is used in the nodes array
*/

// Function to get all relevant node info using trial and error
function getAllNodeInfo(nodeInstance, index) {
    let functionNodeInfo = {};

    functionNodeInfo["index"] = index;
    functionNodeInfo["type"] = nodeInstance["Data"]["$type"];
    try {
        const depoPathMeshJS = nodeInstance["Data"]["mesh"]["DepotPath"];
        for (let key in depoPathMeshJS) {
            if (key.includes("value")) {
                functionNodeInfo["mesh"] = depoPathMeshJS[key];
            }
        }
    } catch (error) {
        functionNodeInfo["mesh"] = null;
    }
    try {
        const depoPathEntJS = nodeInstance["Data"]["entityTemplate"]["DepotPath"];
        for (let key in depoPathEntJS) {
            if (key.includes("value")) {
                functionNodeInfo["entTemplate"] = depoPathEntJS[key];
            }
        }
    } catch (error) {
        functionNodeInfo["entTemplate"] = null;
    }
    try {
        functionNodeInfo["actors"] = nodeInstance["Data"]["compiledData"]["Data"]["Actors"];
    } catch (error) {
        functionNodeInfo["actors"] = null;
    }
    return functionNodeInfo;

}

// Aligns the cube to the selection cube's local space
function alignCubeToSelectionCube(cube) {
    // Extract the selection box properties
    const { minPoint, maxPoint, quat } = SelectionBox;

    // Calculate the center of the selection box
    const centerX = (minPoint.x + maxPoint.x) / 2;
    const centerY = (minPoint.y + maxPoint.y) / 2;
    const centerZ = (minPoint.z + maxPoint.z) / 2;

    // Translate and rotate each vertex of the cube
    cube.vertices = cube.vertices.map(vertex => {
        // Translate the vertex to the center of the selection box
        const translatedVertex = {
            x: vertex.x + centerX,
            y: vertex.y + centerY,
            z: vertex.z + centerZ,
            w: vertex.w // Assuming w remains unchanged
        };

        // Rotate the translated vertex using the selection box's quaternion
        return applyQuaternionRotation(translatedVertex, quat);
    });

    return cube;
}

// Function to rotate a vertex using a quaternion
function applyQuaternionRotation(vertex, quat) {
    // Decompose the quaternion into components
    const { i: qi, j: qj, k: qk, r: qr } = quat;

    // Perform the rotation (quaternion-vector multiplication)
    const ii = qr * vertex.i + qj * vertex.k - qk * vertex.j;
    const ij = qr * vertex.j + qk * vertex.i - qi * vertex.k;
    const ik = qr * vertex.k + qi * vertex.j - qj * vertex.i;
    const ir = -qi * vertex.i - qj * vertex.j - qk * vertex.k;

    return {
        i: ii * qr + ir * -qi + ij * -qk - ik * -qj,
        j: ij * qr + ir * -qj + ik * -qi - ii * -qk,
        k: ik * qr + ir * -qk + ii * -qj - ij * -qi,
        r: vertex.r
    };
}

// Check If Vertex Is Inside Selection Box
function isVertexInsideSelectionBox(vertex) {
    const { minPoint, maxPoint } = SelectionBox;
    if (vertex.x >= minPoint.x && vertex.x <= maxPoint.x) {
        return true
    }
    if (vertex.y >= minPoint.y && vertex.y <= maxPoint.y) {
        return true
    }
    if (vertex.z >= minPoint.z && vertex.z <= maxPoint.z) {
        return true
    }
    return false;
}

// Check if Edge Is Intersecting Selection Box
function isFaceIntersectingSelectionBox(face) {
    const { minPoint, maxPoint } = SelectionBox;

    // Check if any edge of the face intersects with any edge of the selection box
    const faceEdges = [
        { points: [face[0], face[1]], vector: vectorBetweenPoints(face[0], face[1]) },
        { points: [face[1], face[2]], vector: vectorBetweenPoints(face[1], face[2]) },
        { points: [face[2], face[0]], vector: vectorBetweenPoints(face[2], face[0]) }
    ];

    const selectionBoxEdges = SelectionBox.edges;

    for (const faceEdge of faceEdges) {
        for (const selectionBoxEdge of selectionBoxEdges) {
            if (doEdgesIntersect(faceEdge, selectionBoxEdge)) {
                return true;
            }
        }
    }

    return false;
}

// Function to check if two edges intersect
function doEdgesIntersect(edge1, edge2) {
    const [p1, p2] = edge1.points;
    const [q1, q2] = edge2.points;

    const d1 = direction(q1, q2, p1);
    const d2 = direction(q1, q2, p2);
    const d3 = direction(p1, p2, q1);
    const d4 = direction(p1, p2, q2);

    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {
        return true;
    }

    if (d1 === 0 && onSegment(q1, q2, p1)) {
        return true;
    }

    if (d2 === 0 && onSegment(q1, q2, p2)) {
        return true;
    }

    if (d3 === 0 && onSegment(p1, p2, q1)) {
        return true;
    }

    if (d4 === 0 && onSegment(p1, p2, q2)) {
        return true;
    }

    return false;
}

// Helper function to calculate the direction
function direction(p1, p2, p3) {
    return (p3.x - p1.x) * (p2.y - p1.y) - (p3.y - p1.y) * (p2.x - p1.x);
}

// Helper function to check if a point is on a segment
function onSegment(p1, p2, p) {
    return (
        Math.min(p1.x, p2.x) <= p.x && p.x <= Math.max(p1.x, p2.x) &&
        Math.min(p1.y, p2.y) <= p.y && p.y <= Math.max(p1.y, p2.y)
    );
}

// Check if cube intersects with selection box
function doCubeIntersectWithSelectionBox(cubeAligned) {
    // const cubeAligned = alignCubeToSelectionCube(cube);
    if (cubeAligned.maxPoint === cubeAligned.minPoint) {
        if (isVertexInsideSelectionBox(cubeAligned.vertices[0])) {
            return true;
        } else {
            return false;
        }
    }
    for (const vertex of cubeAligned.vertices) {
        if (isVertexInsideSelectionBox(vertex)) {
            return true;
        }
    }
    for (const face of cubeAligned.faces) {
        if (isFaceIntersectingSelectionBox(face)) {
            return true;
        }
    }
    return false;
}

// Check if Sphere Intersects with Selection Box
function isSphereIntersectingSelectionBox(sphere) {
    const selectionBoxMin = selectionBox.min;
    const selectionBoxMax = selectionBox.max;

    const sphereCenter = sphere.center;
    const sphereRadius = sphere.radius;

    // Check if the sphere is outside the selection box
    if (sphereCenter.x + sphereRadius < selectionBoxMin.x || sphereCenter.x - sphereRadius > selectionBoxMax.x) {
        return false;
    }
    if (sphereCenter.y + sphereRadius < selectionBoxMin.y || sphereCenter.y - sphereRadius > selectionBoxMax.y) {
        return false;
    }
    if (sphereCenter.z + sphereRadius < selectionBoxMin.z || sphereCenter.z - sphereRadius > selectionBoxMax.z) {
        return false;
    }

    // If none of the above, the sphere intersects the selection box
    return true;


}

// Checks if the selection box is included in the cube
function isSelectionBoxInsideCube(cube) {
    // Will need to be implemented, however it is not a priority
}

// decode absolute coordinates
function decodeAbsoluteCoordinates(coordinates) {
    let decodedCoordinates = {x: 0, y: 0, z: 0};
    decodedCoordinates.x = decodeFixedPoint(coordinates.x);
    decodedCoordinates.y = decodeFixedPoint(coordinates.y);
    decodedCoordinates.z = decodeFixedPoint(coordinates.z);
    return decodedCoordinates;
}
// Helper function to decode the fixed point
function decodeFixedPoint(value) {
    // Assuming 32-bit fixed-point with 16.16 format
    const INTEGER_BITS = 16;
    const FRACTIONAL_BITS = 16;
    
    // Convert to signed integer if necessary
    if (value > 2**31 - 1) {
        value -= 2**32;
    }

    // Separate integer and fractional parts
    const integerPart = value >> FRACTIONAL_BITS;
    const fractionalPart = value & ((1 << FRACTIONAL_BITS) - 1);

    // Convert fractional part to decimal
    const fractionalDecimal = fractionalPart / (2**FRACTIONAL_BITS);

    // Combine integer and fractional parts
    const result = integerPart + fractionalDecimal;

    return result;
}


// Main Loop
for (const sectorPath of InputJson.sectors) {
    // Defines constants
    const sectorGameFile = wkit.GetFileFromArchive(sectorPath, OpenAs.GameFile);
    const sectorJson = TypeHelper.JsonParse(wkit.GameFileToJson(sectorGameFile));
    // Getting the node data
    const nodeData = sectorJson["Data"]["RootChunk"]["nodeData"]["Data"];
    const nodes = sectorJson["Data"]["RootChunk"]["nodes"];
    // Arrays to store the node connections
    let NodeInfo = [];
    // Indexing the nodes
    let i = 0;
    // Looping through the nodes
    for (let nodeInstance of nodes) {
        i += 1;
        const nodeType = nodeInstance["Data"]["$type"];
        // Checking if the node type is not undefined
        if (nodeType !== null) {
            // Checking if the node type includes the SelectVariable
            for (const selecVar of SelectVariableArray) {
                if (nodeType.includes(selecVar)) {
                    // adding the node info to the temp output json
                    NodeInfo.push(getAllNodeInfo(nodeInstance, i));
                }
            }
        }
    }
    // Looping through the node data
    let nodesOutput = [];
    for (let nodeDataIndex in nodeData) {
        for (let nodeInfoIndex in NodeInfo) {
            if (nodeData[nodeDataIndex]["NodeIndex"] === NodeInfo[nodeInfoIndex]["index"]) {
                // Build Cube
                let cubeMin = {x: nodeData[nodeDataIndex]["Bounds"]["Min"]["X"], y: nodeData[nodeDataIndex]["Bounds"]["Min"]["Y"], z: nodeData[nodeDataIndex]["Bounds"]["Min"]["Z"], w: nodeData[nodeDataIndex]["Bounds"]["Min"]["W"]};
                let cubeMax = {x: nodeData[nodeDataIndex]["Bounds"]["Max"]["X"], y: nodeData[nodeDataIndex]["Bounds"]["Max"]["Y"], z: nodeData[nodeDataIndex]["Bounds"]["Max"]["Z"], w: nodeData[nodeDataIndex]["Bounds"]["Max"]["W"]};
                let cubeQuat = {i: nodeData[nodeDataIndex]["Orientation"]["i"], j: nodeData[nodeDataIndex]["Orientation"]["j"], k: nodeData[nodeDataIndex]["Orientation"]["k"], r: nodeData[nodeDataIndex]["Orientation"]["r"]};
                const cube = new Cube(cubeMin, cubeMax, cubeQuat);
//                Logger.Info("cubeMin: ");
//                Logger.Info(cubeMin);
//                Logger.Info("cubeMax: ");
//                Logger.Info(cubeMax);
//                Logger.Info("cubeQuat: ");
//              Logger.Info(cubeQuat);
                // Check if cube intersects with selection box
                if (doCubeIntersectWithSelectionBox(cube) === true) {
                    Logger.Info(nodeDataIndex + " intersects with selection box");
                    if (NodeInfo[nodeInfoIndex]["actors"] === null) {
                        nodesOutput.push({"Index":nodeDataIndex,"Type":NodeInfo[nodeInfoIndex]["type"]});
                    }
                    if (NodeInfo[nodeInfoIndex]["actors"] !== null) {
                        let actorOutput = [];
                        let actorIndex = 0;
                        for (let actor of NodeInfo[nodeInfoIndex]["actors"]) {
                            let actorDecodedCoordinates = decodeAbsoluteCoordinates({x: actor["Position"]["X"], y: actor["Position"]["Y"], z: actor["Position"]["Z"]});
                            actorIndex += 1;
                            if (actor["Shapes"]["ShapeType"] === "Box") {
                                // Build Cube
                                let actorCubeMin = {x: actor["Position"]["X"], y: actor["Position"]["Y"], z: actor["Position"]["Z"], w: actor["Position"]["W"]};
                                let actorCubeMax = {x: actor["Position"]["X"] + actor["Shapes"]["Size"]["X"], y: actor["Position"]["Y"] + actor["Shapes"]["Size"]["Y"], z: actor["Position"]["Z"] + actor["Shapes"]["Size"]["Z"], w: actor["Position"]["W"]};
                                let actorCubeQuat = {x: actor["Rotation"]["I"], y: actor["Rotation"]["J"], z: actor["Rotation"]["K"], w: actor["Rotation"]["R"]};
                                let absoluteActorCubeMin = {x: actorDecodedCoordinates.x + actorCubeMin.x, y: actorDecodedCoordinates.y + actorCubeMin.y, z: actorDecodedCoordinates.z + actorCubeMin.z, w: actorCubeMin.w};
                                let absoluteActorCubeMax = {x: actorDecodedCoordinates.x + actorCubeMax.x, y: actorDecodedCoordinates.y + actorCubeMax.y, z: actorDecodedCoordinates.z + actorCubeMax.z, w: actorCubeMax.w};
                                const actorCube = new Cube(absoluteActorCubeMin, absoluteActorCubeMax, actorCubeQuat);
                                // Check if cube intersects with selection box
                                if (doCubeIntersectWithSelectionBox(actorCube) === true) {
                                    actorOutput.push(actorIndex);
                                }
                            }
                            if (actor["Shapes"]["ShapeType"] === "Sphere") {
                                Logger.Info("Actor is a sphere");
                            }
                            try {
                                if (actor["Shapes"]["ShapeType"].includes("Mesh")) {
                                    // Implement Mesh Collision Check
                                    Logger.Info("Actor is a mesh");
                                }
                            } catch (error) {
                                Logger.Error("Error: " + error);
                            }
                        }
                        nodesOutput.push({"Index":nodeDataIndex,"Type":NodeInfo[nodeInfoIndex]["type"],"Actors":actorOutput});
                    }
                } else {
//                    Logger.Info(nodeDataIndex + " does not intersect with selection box");
//                   Logger.Info("");
                }
            }
        }
    }
Logger.Info(nodesOutput);
}


/*
let testCube = new Cube({x: -1341.1886, y: 1212.69824, z: 115, w: 0}, {x: -1343.19446, y: 1212.71851, z: 116.900002, w: 0}, {i: 0, j: 0, k: 0, r: 0});
Logger.Info(doCubeIntersectWithSelectionBox(testCube));

Logger.Info("Selection Box Min Point: ");   
Logger.Info(SelectionBox.minPoint);
Logger.Info("Selection Box Max Point: ");
Logger.Info(SelectionBox.maxPoint);
Logger.Info("Test Cube Min Point: ");
Logger.Info(testCube.minPoint);
Logger.Info("Test Cube Max Point: ");
Logger.Info(testCube.maxPoint);
*/