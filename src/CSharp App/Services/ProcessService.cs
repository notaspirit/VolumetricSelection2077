using System;
using System.Threading.Tasks;
using System.Collections.Generic;
using VolumetricSelection2077.Models;
using System.Linq;
using System.Text.RegularExpressions;
using DynamicData;
using MessagePack;
using VEnums = VolumetricSelection2077.Enums;
using WEnums = WolvenKit.RED4.Types.Enums;
using SharpDX;

namespace VolumetricSelection2077.Services;

public class ProcessService
{
    private readonly SettingsService _settings;
    private readonly GameFileService _gameFileService;
    private readonly CacheService _cacheService;
    private readonly PostProcessingService _postProcessingService;
    private readonly Progress _progress;
    public ProcessService()
    {
        _settings = SettingsService.Instance;
        _gameFileService = GameFileService.Instance;
        _progress = Progress.Instance;
        _cacheService = CacheService.Instance;
        _postProcessingService = new PostProcessingService();
    }
    
    /// <summary>
    /// Processes all sectors in the selection file generated by the CET part and saves a removal file to the set location if intersections with the obb were found
    /// </summary>
    /// <param name="inputFile"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentException">Provided custom file does not exist, or only one optional param is provided</exception>
    public async Task<(bool success, string error)> MainProcessTask(SelectionInput inputFile)
    {
        AxlRemovalSector?[] sectorsOutputRaw;

        var vanillaBoundingBoxes = _cacheService.GetAllEntries(VEnums.CacheDatabases.VanillaBounds);
        
        inputFile.Sectors.Add(vanillaBoundingBoxes
            .Where(x => inputFile.Aabb.Contains(MessagePackSerializer.Deserialize<BoundingBox>(x.Value)) != ContainmentType.Disjoint)
            .Select(x => x.Key));

        if (_settings.SupportModdedResources)
        {
            var moddedBoundingBoxes = _cacheService.GetAllEntries(VEnums.CacheDatabases.ModdedBounds);
            inputFile.Sectors.Add(moddedBoundingBoxes
                .Where(x => inputFile.Aabb.Contains(MessagePackSerializer.Deserialize<BoundingBox>(x.Value)) != ContainmentType.Disjoint)
                .Select(x => x.Key));
        }

        Logger.Info($"Found {inputFile.Sectors.Count} sectors to process...");
        
        _progress.AddCurrent(1, Progress.ProgressSections.Startup);
        
        try
        {
            _progress.AddTarget(inputFile.Sectors.Count, Progress.ProgressSections.Processing);
            var tasks = inputFile.Sectors.Select(input => Task.Run(() => SectorProcessThread(input, inputFile)));
            sectorsOutputRaw = await Task.WhenAll(tasks);
        }
        finally
        {
            _cacheService.StopListening();
        }
        
        _postProcessingService.Run(sectorsOutputRaw);
        
        return (true, string.Empty);
    }
    
    // also returns null if none of the nodes in the sector are inside the box
    private async Task<(bool success, string error, AxlRemovalSector? result)> ProcessStreamingsector(AbbrSector sector, string sectorPath, SelectionInput selectionBox)
    {
        var tasks = sector.NodeData.Select((input, index) => Task.Run(() => ProcessNodeAsync(input, index, sector, selectionBox))).ToArray();

        var nodeDeletionsRaw = await Task.WhenAll(tasks);
        
        List<AxlRemovalNodeDeletion> nodeDeletions = nodeDeletionsRaw.OfType<AxlRemovalNodeDeletion>().ToList();

        _progress.AddCurrent(1, Progress.ProgressSections.Processing);
        
        if (nodeDeletions.Count == 0)
        {
            return (true, "No Nodes Intersect with Box.", null);
        }

        var result = new AxlRemovalSector()
        {
            NodeDeletions = nodeDeletions,
            ExpectedNodes = sector.NodeData.Length,
            Path = sectorPath
        };
        return (true, "", result);
    }
    
    private async Task<AxlRemovalSector?> SectorProcessThread(string streamingSectorName, SelectionInput CETOutputFile)
    {
        Logger.Info($"Starting sector process thread for {streamingSectorName}...");
        try
        {
            string streamingSectorNameFix = Regex.Replace(streamingSectorName, @"\\{2}", @"\");
            var sector = _gameFileService.GetSector(streamingSectorNameFix);
            if (sector == null)
            {
                Logger.Warning($"Failed to find sector {streamingSectorNameFix}");
                return null;
            }
                
            var (successPSS, errorPSS, resultPss) = await ProcessStreamingsector(sector, streamingSectorName, CETOutputFile);
            if (successPSS)
            { 
                Logger.Info($"Successfully processed streamingsector {streamingSectorName} which found {resultPss?.NodeDeletions.Count ?? 0} nodes out of {sector.NodeData.Length} nodes.");
                return resultPss;
            }
            
            Logger.Error($"Failed to processes streamingsector {streamingSectorName} with error: {errorPSS}");
            return null;
        }
        catch (Exception e)
        {
            Logger.Exception(e, $"Failed to process sector {streamingSectorName} with error {e.Message}");;
            return null;
        }
    }
    
    private async Task<AxlRemovalNodeDeletion?> ProcessNodeAsync(AbbrStreamingSectorNodeDataEntry nodeDataEntry, int index, AbbrSector sector, SelectionInput selectionBox)
    {
        var nodeEntry = sector.Nodes[nodeDataEntry.NodeIndex];
        
        bool? matchesDebugFilter = null;
        bool? matchesResourceFilter = null;
        
        if (_settings.DebugNameFilter.Count > 0)
        {
            matchesDebugFilter = false;
            foreach (var filter in _settings.DebugNameFilter)
            {
                if (Regex.IsMatch(nodeEntry.DebugName ?? "", filter, RegexOptions.IgnoreCase))
                {
                    matchesDebugFilter = true;
                    break;
                }
            }
            
        }
        
        if (_settings.ResourceNameFilter.Count > 0)
        {
            matchesResourceFilter = false;
            foreach (var filter in _settings.ResourceNameFilter)
            {
                if (Regex.IsMatch(nodeEntry.ResourcePath ?? "", filter, RegexOptions.IgnoreCase))
                {
                    matchesResourceFilter = true;
                    break;
                }
            }
        }

        if (matchesDebugFilter != null && matchesResourceFilter != null)
        {
            if (_settings.FilterModeOr)
            {
                if (!((bool)matchesDebugFilter || (bool)matchesResourceFilter))
                {
                    return null;
                }
            }
            else
            {
                if (!((bool)matchesDebugFilter && (bool)matchesResourceFilter))
                {
                    return null;
                }
            }
        } 
        else if (matchesDebugFilter.HasValue && matchesDebugFilter == false)
        {
            return null;
        }
        else if (matchesResourceFilter.HasValue && matchesResourceFilter == false)
        {
            return null;
        }
        
        if (_settings.NodeTypeFilter[(int)nodeEntry.Type] != true)
        {
            return null;
        }
        
        
        VEnums.CollisionCheckTypes entryType = VEnums.CollisionCheckTypes.Default;
        if ((nodeEntry.ResourcePath?.EndsWith(@".mesh") ?? false) || (nodeEntry.ResourcePath?.EndsWith(@".w2mesh") ?? false))
        {
            entryType = VEnums.CollisionCheckTypes.Mesh;
        } 
        else if (nodeEntry.SectorHash != null && (nodeEntry.Actors != null || nodeEntry.Actors?.Length > 0))
        {
            entryType = VEnums.CollisionCheckTypes.Collider;
        }

        switch (entryType)
        {
            case VEnums.CollisionCheckTypes.Mesh:
                if (nodeDataEntry.AABB != null)
                {
                    BoundingBox nodeAABB = (BoundingBox)nodeDataEntry.AABB;
                    if (selectionBox.Obb.Contains(ref nodeAABB) == ContainmentType.Disjoint)
                        return null;
                }
                
                bool isInstanced = nodeEntry.Type is VEnums.NodeTypeProcessingOptions.worldInstancedDestructibleMeshNode 
                                                    or VEnums.NodeTypeProcessingOptions.worldInstancedMeshNode;
                
                if (!isInstanced && _settings.SaveFileFormat == VEnums.SaveFileFormat.WorldBuilder)
                    isInstanced = nodeEntry.Type is VEnums.NodeTypeProcessingOptions.worldFoliageNode;
                
                var mesh = _gameFileService.GetCMesh(nodeEntry.ResourcePath);
                if (mesh == null)
                {
                    Logger.Warning($"Failed to get CMesh from {nodeEntry.ResourcePath}");
                    return null;
                }
                var (isInside, instances) = CollisionCheckService.IsMeshInsideBox(mesh,
                    selectionBox.Obb,
                    selectionBox.Aabb,
                    nodeDataEntry.Transforms,
                    checkAllTransforms: isInstanced);

                if (!isInside) 
                    return null;
                
                if (isInstanced)
                    return new AxlRemovalNodeDeletion
                    {
                        Index = index,
                        Type = nodeEntry.Type.ToString(),
                        ActorDeletions = instances,
                        ExpectedActors = nodeDataEntry.Transforms.Length
                    };
                return new AxlRemovalNodeDeletion
                {
                    Index = index,
                    Type = nodeEntry.Type.ToString()
                };
            case VEnums.CollisionCheckTypes.Collider:
                List<int> actorRemoval = new List<int>();
                int actorIndex = 0;
                foreach (var actor in nodeEntry.Actors)
                {
                    var shapeIntersects = false;
                    var sectorHash = nodeEntry.SectorHash;
                    var transformActor = actor.Transform;
                    
                    foreach (var shape in actor.Shapes)
                    {
                        switch (shape.ShapeType)
                        {
                            case WEnums.physicsShapeType.TriangleMesh:
                            case WEnums.physicsShapeType.ConvexMesh:
                                var collisionMesh = await _gameFileService.GetPhysXMesh((ulong)sectorHash, (ulong)shape.Hash);
                                if (collisionMesh == null)
                                {
                                    Logger.Warning($"Failed to get PhysX Mesh from {sectorHash} : {shape.Hash}");
                                    continue;
                                }
                                bool isCollisionMeshInsideBox = CollisionCheckService.IsCollisonMeshInsideSelectionBox(collisionMesh, selectionBox.Obb, selectionBox.Aabb, transformActor, shape.Transform);
                                if (isCollisionMeshInsideBox)
                                {
                                    shapeIntersects = true;
                                    goto breakShapeLoop;
                                }
                                break;
                            case WEnums.physicsShapeType.Box:
                                bool isCollisionBoxInsideBox = CollisionCheckService.IsCollisionBoxInsideSelectionBox(shape, transformActor, selectionBox.Aabb,  selectionBox.Obb);
                                if (isCollisionBoxInsideBox)
                                {
                                    shapeIntersects = true;
                                    goto breakShapeLoop;
                                }
                                break;
                            case WEnums.physicsShapeType.Capsule:
                                bool isCollisionCapsuleInsideBox = CollisionCheckService.IsCollisionCapsuleInsideSelectionBox(shape, transformActor, selectionBox.Aabb,  selectionBox.Obb);
                                if (isCollisionCapsuleInsideBox)
                                {
                                    shapeIntersects = true;
                                    goto breakShapeLoop;
                                }
                                break;
                            case WEnums.physicsShapeType.Sphere:
                                bool intersects = CollisionCheckService.IsCollisionSphereInsideSelectionBox(shape, transformActor, selectionBox.Obb);
                                if (intersects)
                                {
                                    shapeIntersects = true;
                                    goto breakShapeLoop;
                                }
                                break;
                        }
                    }
                    
                    breakShapeLoop:
                    if (shapeIntersects)
                    {
                        actorRemoval.Add(actorIndex);
                    }
                    actorIndex++;
                }
                if (actorRemoval.Count > 0)
                {
                    return new AxlRemovalNodeDeletion()
                        {
                            Index = index,
                            Type = nodeEntry.Type.ToString(),
                            ActorDeletions = actorRemoval,
                            ExpectedActors = nodeEntry.Actors.Length
                        };
                }
                return null;
            case VEnums.CollisionCheckTypes.Default:
                foreach (var transform in nodeDataEntry.Transforms)
                {
                    var intersection = selectionBox.Obb.Contains(transform.Position);
                    if (intersection != ContainmentType.Disjoint)
                    {
                        return new AxlRemovalNodeDeletion()
                        {
                            Index = index,
                            Type = nodeEntry.Type.ToString()
                        };
                    }
                }
                return null;
        }
        return null;
    }
}