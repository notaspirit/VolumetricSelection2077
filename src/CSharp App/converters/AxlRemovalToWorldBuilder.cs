using System.Collections.Generic;
using System.Linq;
using DynamicData;
using VolumetricSelection2077.Models;
using VolumetricSelection2077.Models.WorldBuilder.Editor;
using VolumetricSelection2077.Models.WorldBuilder.Spawn;
using VolumetricSelection2077.Models.WorldBuilder.Spawn.Mesh;
using VolumetricSelection2077.Services;
using WolvenKit.RED4.Archive.Buffer;
using WolvenKit.RED4.Archive.CR2W;
using WolvenKit.RED4.Types;
using Vector4 = SharpDX.Vector4;

namespace VolumetricSelection2077.Converters;

public class AxlRemovalToWorldBuilder
{
    private GameFileService _gfs;
    private List<string> _warnedTypes;
    
    public AxlRemovalToWorldBuilder()
    {
        _gfs = GameFileService.Instance;
        _warnedTypes = new List<string>();
    }

    public Element Convert(AxlRemovalFile axlFile, string rootName)
    {
        _warnedTypes.Clear();
        
        var root = new PositionableGroup
        {
            Name = rootName
        };

        foreach (var sector in axlFile.Streaming.Sectors)
        {
            if (sector.NodeDeletions.Count <= 0)
                continue;

            var worldSectorCR2W = _gfs?.ArchiveManager?.GetCR2WFile(sector.Path);
            if (worldSectorCR2W is not { RootChunk: worldStreamingSector wse })
            {
                Logger.Warning($"Failed to get sector {sector.Path}, no nodes from that sector will be added.");
                continue;
            }

            AbbrSector? worldSectorAbbr = null;
            
            var sectorGroup = new PositionableGroup
            {
                Name = sector.Path
            };

            foreach (var node in sector.NodeDeletions)
            {
                sectorGroup.Children.AddRange(ConvertNode(node, wse, ref worldSectorAbbr, sector.Path));
            }
            if (sectorGroup.Children.Count > 0)
                root.Children.Add(sectorGroup);
        }
        
        _warnedTypes.Clear();
        return root;
    }

    private List<Element> ConvertNode(AxlRemovalNodeDeletion remNode, worldStreamingSector sector, ref AbbrSector? worldSectorAbbr, string sectorPath)
    {
        var nodeData = sector.NodeData.Data as CArray<worldNodeData>;
        
        var nodeDataEntry = nodeData[remNode.Index];
        var node = sector.Nodes[nodeDataEntry.NodeIndex].Chunk;

        var spawnableElements = new List<Element>();
        
        switch (node)
        {
            case worldInstancedMeshNode instancedMeshNode:
                if ((string?)instancedMeshNode.Mesh.DepotPath is null)
                    return spawnableElements;

                worldSectorAbbr ??= _gfs.GetSector(sectorPath);
                if (worldSectorAbbr == null)
                    return spawnableElements;
                var abbrInstancedMeshNodeDataEntry = worldSectorAbbr.NodeData[remNode.Index];
                foreach (var transform in abbrInstancedMeshNodeDataEntry.Transforms)
                {
                    if (remNode.ActorDeletions != null && remNode.ActorDeletions.Count != 0)
                    {
                        if (remNode.ActorDeletions.All(x => x != abbrInstancedMeshNodeDataEntry.Transforms.IndexOf(transform)))
                            continue;
                    }
                    
                    spawnableElements.Add(new SpawnableElement
                    {
                        Name = node?.DebugName ?? instancedMeshNode?.Mesh.DepotPath.GetString() ?? "Generated by VS2077",
                        Spawnable = new Mesh
                        {
                            Position = new Vector4(transform.Position, 1),
                            EulerRotation = transform.Rotation,
                            Scale = transform.Scale,
                    
                            CastLocalShadows = instancedMeshNode.CastLocalShadows,
                            CastShadows = instancedMeshNode.CastShadows,
                    
                            PrimaryRange = nodeDataEntry.MaxStreamingDistance,
                            SecondaryRange = nodeDataEntry.UkFloat1,
                            Uk10 = nodeDataEntry.Uk10,
                            Uk11 = nodeDataEntry.Uk11,
                    
                            ResourcePath = instancedMeshNode.Mesh.DepotPath,
                            Appearance = instancedMeshNode.MeshAppearance,
                        }
                    });
                }
                break;
            case worldMeshNode meshNode:
                if ((string?)meshNode.Mesh.DepotPath is null)
                    return spawnableElements;
                
                spawnableElements.Add(new SpawnableElement
                {
                    Name = node?.DebugName ?? meshNode?.Mesh.DepotPath.GetString() ?? "Generated by VS2077",
                    Spawnable = new Mesh
                    {
                        Position = WolvenkitToSharpDX.Vector4(nodeDataEntry.Position),
                        EulerRotation = WolvenkitToSharpDX.Quaternion(nodeDataEntry.Orientation),
                        Scale = WolvenkitToSharpDX.Vector3(nodeDataEntry.Scale),
                    
                        CastLocalShadows = meshNode.CastLocalShadows,
                        CastRayTracedLocalShadows = meshNode.CastRayTracedLocalShadows,
                        CastRayTracedGlobalShadows = meshNode.CastRayTracedGlobalShadows,
                        CastShadows = meshNode.CastShadows,
                    
                        WindImpulseEnabled = meshNode.WindImpulseEnabled,
                    
                        PrimaryRange = nodeDataEntry.MaxStreamingDistance,
                        SecondaryRange = nodeDataEntry.UkFloat1,
                        Uk10 = nodeDataEntry.Uk10,
                        Uk11 = nodeDataEntry.Uk11,
                    
                        ResourcePath = meshNode.Mesh.DepotPath,
                        Appearance = meshNode.MeshAppearance,
                    }
                });
                break;
            default:
                var nodeTypeString = node?.GetType().ToString() ?? "";
                if (!_warnedTypes.Contains(nodeTypeString))
                {
                    Logger.Warning($"{nodeTypeString} is not a supported node type. Skipping...");
                    _warnedTypes.Add(nodeTypeString);
                }
                break;
        }
        return spawnableElements;
    }
}